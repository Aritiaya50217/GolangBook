SOLID Principles
    Design principles เป็นแนวทางที่ใช้ในการออกแบบซอฟต์แวร์เพื่อสร้างโค้ดที่มีคุณภาพสูง โดยการใช้หลักการเหล่านี้ช่วยให้โค้ดมีความยืดหยุ่น, ขยายตัวได้, เข้าใจง่าย, และสามารถบำรุงรักษาได้ดีในระยะยาว หลักการออกแบบมีหลายรูปแบบ แต่จะพูดถึงหลักการสำคัญที่มักถูกใช้ในอุตสาหกรรมซอฟต์แวร์

    1. SOLID Principles
        SOLID เป็นชุดของ 5 หลักการที่ใช้ในการออกแบบซอฟต์แวร์ที่เน้นการจัดระเบียบโค้ดให้มีความยืดหยุ่นและสามารถขยายตัวได้ง่าย

        S - Single Responsibility Principle (SRP):
        หลักการนี้ระบุว่า แต่ละคลาสหรือฟังก์ชันควรมีหน้าที่หรือความรับผิดชอบเพียงหนึ่งเดียว หมายความว่า โค้ดแต่ละส่วนควรรับผิดชอบเพียงแค่ฟังก์ชันเดียวและไม่ควรไปยุ่งเกี่ยวกับงานอื่นๆ ที่ไม่เกี่ยวข้องเช่น, การแยกการจัดการข้อมูลและการแสดงผลออกจากกัน

        O - Open/Closed Principle (OCP):
        หลักการนี้ระบุว่า คลาสหรือฟังก์ชันควรเปิดสำหรับการขยาย (extension) แต่ ปิดสำหรับการแก้ไข (modification) กล่าวคือ, เมื่อเราต้องการเพิ่มฟังก์ชันการทำงานใหม่ในซอฟต์แวร์ เราควรขยายโค้ดที่มีอยู่โดยไม่ต้องแก้ไขโค้ดเดิม
        เช่น, การใช้ inheritance หรือ interfaces เพื่อขยายฟังก์ชัน

        L - Liskov Substitution Principle (LSP):
        หลักการนี้ระบุว่า ถ้า S เป็น subclass ของ T, เราควรจะสามารถแทนที่ T ด้วย S ได้โดยไม่ทำให้โปรแกรมเกิดข้อผิดพลาดหรือการทำงานที่ไม่ถูกต้อง
        กล่าวคือ, class ที่สืบทอดจาก class พื้นฐานควรทำงานได้เหมือนกับ class พื้นฐาน โดยไม่ทำให้เกิดผลลัพธ์ที่ไม่คาดคิด

        I - Interface Segregation Principle (ISP):
        หลักการนี้ระบุว่า ไม่ควรบังคับให้ class ต้องใช้ method ที่มันไม่ได้ใช้ หมายถึง ควรแยก interfaces ออกเป็นส่วนย่อยๆ ตามฟังก์ชันที่ต้องการใช้งานจริง
        เช่น, แทนที่จะให้ class ใช้ interface ที่มี method เยอะเกินไป ควรสร้าง interface ที่เฉพาะเจาะจงตามแต่ละฟังก์ชันการใช้งาน

        D - Dependency Inversion Principle (DIP):
        หลักการนี้ระบุว่า การพึ่งพาควรเกิดขึ้นกับ abstraction (interface หรือ abstract class) แทนที่จะเป็น concrete classes
        กล่าวคือ, แทนที่จะให้ class พึ่งพา class อื่นที่เป็นการ implement จริงๆ เราควรใช้ abstraction เพื่อให้สามารถเปลี่ยนแปลงหรือขยายได้ง่าย

    2. DRY (Don't Repeat Yourself)
        - หลักการ DRY เน้นการหลีกเลี่ยงการทำงานซ้ำซ้อนในโค้ด
        - โค้ดที่ซ้ำกันทำให้การบำรุงรักษายากขึ้น เพราะเมื่อมีการเปลี่ยนแปลงบางอย่างที่จำเป็นต้องเปลี่ยนแปลงทุกที่ที่มีการซ้ำซ้อน
        - ควรจะใช้ฟังก์ชัน, คลาส, หรือวิธีการจัดการข้อมูลที่สามารถนำกลับมาใช้ใหม่ได้เพื่อลดการซ้ำซ้อน

    3. KISS (Keep It Simple, Stupid)
        - หลักการ KISS เน้นการออกแบบให้โค้ดมีความเรียบง่าย ไม่ซับซ้อนเกินไป
        - โค้ดที่ง่ายและเข้าใจได้ง่ายจะช่วยให้การบำรุงรักษาและการขยายตัวในอนาคตทำได้ง่ายขึ้น
        - หลีกเลี่ยงการใช้โค้ดที่ซับซ้อนหรือลูกเล่นที่ไม่จำเป็น

    4. YAGNI (You Aren't Gonna Need It)
        - หลักการ YAGNI เน้นการพัฒนาโค้ดในสิ่งที่จำเป็นจริงๆ
        - การเขียนฟีเจอร์ที่อาจจะไม่จำเป็นในปัจจุบันจะทำให้โค้ดยุ่งเหยิงและซับซ้อน
        - ควรทำการพัฒนาและเพิ่มฟังก์ชันการทำงานตามความต้องการจริงๆ ของโปรเจ็กต์

    5. Composition Over Inheritance
        - หลักการนี้บอกว่า ควรใช้ composition (การรวมหลายๆ struct หรือ object) แทนที่จะใช้ inheritance (การสืบทอดจาก class พื้นฐาน)
        - ใน Go ซึ่งไม่มี class แบบที่พบในภาษา OOP อื่นๆ การใช้ composition จะทำให้โค้ดยืดหยุ่นและขยายตัวได้ดีกว่า

    6. Favor Polymorphism Over Conditionals
        - หลักการนี้แนะนำให้ใช้ polymorphism แทนการใช้ conditionals หรือการตรวจสอบเงื่อนไขในโค้ด
        - เมื่อมีการตรวจสอบประเภทหรือสภาพแวดล้อมต่างๆ ควรใช้วิธีการที่ทำให้โค้ดไม่ซ้ำซ้อน และสามารถขยายได้ง่าย

    7. Separation of Concerns (SoC)
        - หลักการ Separation of Concerns (SoC) คือการแยกส่วนต่างๆ ของโค้ดออกเป็นโมดูลหรือคลาสที่รับผิดชอบงานเฉพาะ
        - การแยกโค้ดในลักษณะนี้ทำให้การบำรุงรักษา, การทดสอบ, และการขยายตัวทำได้ง่าย

    8. Law of Demeter (LoD) - Principle of Least Knowledge
        - หลักการนี้ระบุว่า หนึ่งโมดูลไม่ควรรู้รายละเอียดของโมดูลอื่นๆ มากเกินไป
        - ควรให้โมดูลต่างๆ ทำงานร่วมกันโดยการเรียกใช้ method หรือฟังก์ชันที่จำเป็นเท่านั้น เพื่อลดการเชื่อมโยงระหว่างกัน
สรุป
การปฏิบัติตาม design principles จะช่วยให้โค้ดมีคุณภาพสูง สามารถขยายและบำรุงรักษาได้ง่ายขึ้น การใช้หลักการเหล่านี้ในการออกแบบซอฟต์แวร์จะช่วยให้คุณสร้างระบบที่สามารถรองรับการเปลี่ยนแปลงได้ในอนาคต ลดการซ้ำซ้อน และทำให้โค้ดมีความยืดหยุ่น